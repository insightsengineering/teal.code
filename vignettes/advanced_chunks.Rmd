---
title: "Advanced chunks"
author: "NEST coreDev"
date: "2022-05-09"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Advanced chunks}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## Decoupling chunks containers

In a shiny app there is often a need to have multiple chunks containers that may be used independently by certain parts of the application and may be used together by other parts of the application. The ability to have multiple chunks containers combined into one allows for greater flexibility of the code, which allows the developer to apply the `DRY` principle (stands for `Do not repeat` which means code that are used in multiple places should only be written and defined once) and optimize performance. Much of the functionality to use a single chunks container object independently has already been covered in the [Basic chunks](./basic_chunks.Rmd) vignette, which you should read first before going any further.

## Creating a chunks container and assigning it to a variable

In order to have multiple chunks containers, each must be accessible and distinguishable via a variable.

```{r}
ch_0 <- teal.code::chunks$new()
ch_1 <- teal.code::chunks$new()
ch_2 <- teal.code::chunks$new()

# if data used is static, then it should be computed once
# isolating it into its own chunks container accomplishes this goal
ch_0$push(quote(df <- data.frame(a = runif(5, -10, 10), b = runif(5, -10, 10))))
ch_1$push(quote({
  Sys.sleep(1) # some really long running process
  foo_plot <- function(df_arg) plot(df_arg)
  })
)
ch_2$push(quote({
  Sys.sleep(1) # some really long running process
  foo_print <- function(df_arg) df_arg
  })
)

# chunks containers should be evaluated before being merged
teal.code::chunks_safe_eval(chunks = ch_0)
teal.code::chunks_safe_eval(chunks = ch_1)
teal.code::chunks_safe_eval(chunks = ch_2)
```

The `teal.code::chunks_push_chunks` function is called to combine chunks containers together. Note that the base chunks container to start combining from in the following examples are all empty. However, that does not have to be the case. Starting with a clean slate is easier to comprehend.

Perhaps a part of your shiny application needs to output a plot

```{r}
ch_plot <- teal.code::chunks$new()
teal.code::chunks_push_chunks(ch_0, chunks = ch_plot)
teal.code::chunks_push_chunks(ch_1, chunks = ch_plot)
teal.code::chunks_push(quote(foo_plot(df)), chunks = ch_plot)
teal.code::chunks_safe_eval(chunks = ch_plot)
```

Perhaps a part of your shiny application needs to output a table

```{r}
ch_table <- teal.code::chunks$new()
teal.code::chunks_push_chunks(ch_0, chunks = ch_table)
teal.code::chunks_push_chunks(ch_2, chunks = ch_table)
teal.code::chunks_push(quote(foo_print(df)), chunks = ch_table)
teal.code::chunks_safe_eval(chunks = ch_table)
```

Perhaps the main part of your shiny application needs to output a plot, a table, and the code to generate both

```{r}
ch_ouput <- teal.code::chunks$new()
teal.code::chunks_push_chunks(ch_0, chunks = ch_ouput)
teal.code::chunks_push_chunks(ch_1, chunks = ch_ouput)
teal.code::chunks_push_chunks(ch_2, chunks = ch_ouput)
teal.code::chunks_push(quote(foo_plot(df)), chunks = ch_ouput)
teal.code::chunks_push(quote(foo_print(df)), chunks = ch_ouput)
teal.code::chunks_safe_eval(chunks = ch_ouput)

code <- teal.code::chunks_get_rcode(chunks = ch_ouput)
cat(
  paste(code, collapse = "\n")
)
```

When chunks containers are merged together, their code expressions are combined in the order that the containers were merged and their environments are combined into a single environment. 

Even in the event that the expressions that are combined will lead to errors being thrown when evaluated, there is no way for the chunks object to know that before evaluation. Hence code expressions will not interrupt the merging of chunks containers together.

However, the potential conflict of when two chunks containers have the same variables which holds different values in their respective environments will throw an error when merging chunks containers.

```{r}
ch_0 <- teal.code::chunks$new()
ch_1 <- teal.code::chunks$new()

ch_0$push(quote(a_var <- 0))
ch_1$push(quote(a_var <- 0))

teal.code::chunks_safe_eval(chunks = ch_0)
teal.code::chunks_safe_eval(chunks = ch_1)

# OK - operation is successful as the variable a_var holds the same value in both chunks
teal.code::chunks_push_chunks(ch_1, chunks = ch_0)

ch_2 <- teal.code::chunks$new()
ch_2$push(quote(a_var <- 1))
teal.code::chunks_safe_eval(chunks = ch_2)

# ERROR - operation is rejected as the variable a_var holds different values
tryCatch(
 teal.code::chunks_push_chunks(ch_2, chunks = ch_0),
 error = function(e) e
)
```

## Cloning a chunks container

A chunks container is an R6 reference class, so by default contains a `clone` method. A deep copy is needed if some part of your app needs to start from the state of an already existing chunks container and modify or add on to it, but some other part of your app still needs the original chunks container unaltered.

The example code below is another way to print the plot above, which starts combining chunks from a non-empty chunks container derived from cloning another chunks container

```{r}
ch_0 <- teal.code::chunks$new()
ch_0$push(quote({
  df <- data.frame(a = runif(5, -10, 10), b = runif(5, -10, 10))
  foo_plot <- function(df_arg) plot(df_arg)
  })
)
teal.code::chunks_safe_eval(chunks = ch_0)

ch_plot_clone <- ch_0$clone(deep = TRUE)
teal.code::chunks_push(quote(foo_plot(df)), chunks = ch_plot_clone)
teal.code::chunks_safe_eval(chunks = ch_plot_clone)
```

## Extracting values of variables in a chunks container

In order to extract values of variables inside a chunks container, the code that generates that variable must have been evaluated

```{r}
ch_0 <- teal.code::chunks$new()
ch_0$push(quote(df <- data.frame(a = runif(5, -10, 10), b = runif(5, -10, 10))))
teal.code::chunks_safe_eval(chunks = ch_0)

env <- new.env()
env$df <- teal.code::chunks_get_var(var = "df", chunks = ch_0)

# Once extracted, the value can be passed into other chunks containers if needed

ch_print_df <- teal.code::chunks$new()
teal.code::chunks_reset(envir = env, chunks = ch_print_df)
teal.code::chunks_push(quote(df), chunks = ch_print_df)
teal.code::chunks_safe_eval(chunks = ch_print_df)
```


# Example

The following is a shiny app that uses the chunks container object in ways that mirror how a sophistical `teal` app would use it. This app constructs several chunks containers, allowing each to be used and combined by different parts of the app, which enables the app to apply the `DRY` principle and optimize performance.

```{r, eval = FALSE}
library(shiny)
library(teal.code)
library(dplyr)
library(rlang)

ui <- fluidPage(
  sidebarLayout(
    sidebarPanel(
      # Input of Response can be chosen from Event Table
      selectInput(
        inputId = "filter_paramcd",
        label = "Filter Paramcd",
        choices = c("OS", "EFS", "PFS"),
        selected = "OS",
        multiple = TRUE
      ),
      selectInput(
        inputId = "filter_sex",
        label = "Filter sex",
        choices = c("F", "M", "U"),
        selected = c("F", "M", "U"),
        multiple = TRUE
      ),
      selectInput(
        inputId = "anl_columns",
        label = "ANL columns",
        choices = NULL,
        multiple = TRUE
      )
    ),
    mainPanel(
      verbatimTextOutput("code"),
      plotOutput("plot"),
      DT::DTOutput("anl_table")
    )
  )
)

server <- function(input, output, session) {
  # chunks container to hold the datasets used in this app.
  # The purpose of storing the code to generate the datasets is reproducibility.
  data_def_chunks <- chunks$new()
  chunks_push(
    expression = quote({
      library(shiny)
      library(teal.code)
      library(dplyr)
      library(rlang)
    }),
    chunks = data_def_chunks
  )
  chunks_push(
    expression = quote(
      adsl <- list(
        SUBJID = 1:100,
        STUDYID = c(rep(1, 20), rep(2, 50), rep(3, 30)),
        AGE = sample(20:88, 100, replace = T) %>% as.numeric(),
        SEX = sample(c("M", "F", "U"), 100, replace = T) %>% as.factor()
      ) %>%
        as_tibble()
    ),
    chunks = data_def_chunks
  )
  chunks_push(
    expression = quote(
      events <- list(
        SUBJID = rep(1:100, 3),
        STUDYID = rep(c(rep(1, 20), rep(2, 50), rep(3, 30)), 3),
        PARAMCD = c(rep("OS", 100), rep("EFS", 100), rep("PFS", 100)),
        AVAL = c(rexp(100, 1 / 100), rexp(100, 1 / 80), rexp(100, 1 / 60)) %>% as.numeric(),
        AVALU = rep("DAYS", 300) %>% as.factor()
      ) %>%
        as_tibble()
    ),
    chunks = data_def_chunks
  )
  # evaluating the code so that the datasets become available
  chunks_safe_eval(data_def_chunks)

  # reactive that needs to extract a value from another chunks container
  adsl_filtered_reactive <- reactive({
    env <- new.env()
    env$adsl <- chunks_get_var(var = "adsl", chunks = data_def_chunks)
    ch <- chunks$new()
    chunks_reset(chunks = ch, env = env)
    chunks_push(
      chunks = ch,
      expr(adsl_filtered <- adsl %>% dplyr::filter(SEX %in% !!input$filter_sex))
    )
    chunks_safe_eval(ch)
    ch
  })

  # reactive that needs to extract a value from another chunks container
  events_filtered_reactive <- reactive({
    env <- new.env()
    env$events <- chunks_get_var(var = "events", chunks = data_def_chunks)
    ch <- chunks$new()
    chunks_reset(chunks = ch, env = env)
    chunks_push(
      chunks = ch,
      expr(events_filtered <- events %>% dplyr::filter(PARAMCD %in% !!input$filter_paramcd))
    )
    chunks_safe_eval(ch)
    ch
  })

  # part of the app that merges two other chunks containers
  merge_data <- reactive({
    ch <- chunks$new()

    chunks_push_chunks(chunks = ch, adsl_filtered_reactive())
    chunks_push_chunks(chunks = ch, events_filtered_reactive())

    chunks_push(
      chunks = ch,
      expr(anl <- left_join(adsl_filtered, events_filtered, by = c("STUDYID", "SUBJID")))
    )
    chunks_safe_eval(ch)
    ch
  })

  observeEvent(merge_data(), {
    anl <- chunks_get_var("anl", merge_data())
    updateSelectInput(
      session,
      "anl_columns",
      choices = colnames(anl),
      selected = colnames(anl)
    )
  })

  # need to clone as chunks are R6 object - this would change ch in merge_data()
  subset_anl <- reactive({
    ch <- merge_data()$clone(deep = TRUE)
    chunks_push(
      rlang::expr(anl_subset <- anl[!!input$anl_columns]),
      chunks = ch
    )
    chunks_safe_eval(ch)
    ch
  })

  # a chunks container that needs to extract a value from another chunks container
  table_call <- reactive({
    env <- new.env()
    env$anl_subset <- chunks_get_var(chunks = subset_anl(), var = "anl_subset")
    ch <- chunks$new()
    chunks_reset(chunks = ch, env = env)
    chunks_push(
      rlang::expr({
        table <- DT::datatable(anl_subset)
        table
      }),
      chunks = ch
    )
    chunks_safe_eval(ch)
    ch
  })

  # a chunks container that needs to extract a value from another chunks container
  plot_call <- reactive({
    env <- new.env()
    env$anl_subset <- chunks_get_var(chunks = subset_anl(), var = "anl_subset")
    ch <- chunks$new()
    chunks_reset(chunks = ch, env = env)
    chunks_push(
      rlang::expr({
        plot_output <- plot(anl_subset$AGE, anl_subset$AVAL)
        plot_output
      }),
      chunks = ch
    )
    chunks_safe_eval(ch)
    ch
  })

  # Really long running process that should not be recomputed if can be avoided.
  #
  # The ability to put this process in its own chunks container, independent of the rest,
  # allows the app to avoid re-computation and yet be able to capture its code to ensure reproducibility.
  sleep_5_seconds <- reactive({
    ch <- chunks$new()
    chunks_push(
      quote(Sys.sleep(5)),
      chunks = ch
    )
    chunks_safe_eval(ch)
    ch
  })

  # part of the app that needs to combine all chunks containers
  outputs_call <- reactive({
    ch <- chunks$new()
    chunks_push_chunks(chunks = ch, data_def_chunks)
    chunks_push_chunks(chunks = ch, sleep_5_seconds())
    chunks_push_chunks(chunks = ch, subset_anl())
    chunks_push_chunks(chunks = ch, plot_call())
    chunks_push_chunks(chunks = ch, table_call())
    ch
  })

  # part of the app that only needs a single chunks container
  output$anl_table <- DT::renderDT(chunks_get_var("table", table_call()))
  output$plot <- renderPlot(chunks_get_var("plot_output", plot_call()))

  output$code <- renderPrint({
    cat(
      paste(
        chunks_get_rcode(chunks = outputs_call()),
        collapse = "\n"
      )
    )
  })
}

shinyApp(ui, server)
```

## Conclusion

The ability to have multiple chunks containers combined into one allows for greater flexibility of the code, which allows the developer to apply the `DRY` principle and optimize performance.
