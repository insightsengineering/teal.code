---
title: "Basic chunks"
author: "NEST coreDev"
date: "2022-04-22"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Basic chunks}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# The chunks container

The main concept behind code reproducibility is the chunks container object. This object consists of two elements:

1. A stack of quoted R expressions, each called a "chunk"
2. An environment carrying variable values

<img src="images/container.png" alt="container" style="width: 100%;"/>

The chunks container object allows the evaluation of all expressions it contains in its own isolated environment, thus having no side effects on the surrounding environment.

The next sections will explain what a chunk is and how it is evaluated.

# What is a chunk?

A quoted R expression is a necessary step to create a **chunk** object, which is an R6 object of class `chunk_call`. Quoted R expressions can be created in three different ways:
```{r}
a <- 3

# Creating a chunk by quote ------------------------------
expr_a <- quote(sum(a, a))
print(expr_a)
print(class(expr_a))


# Creating a chunk by bquote ------------------------------
expr_b <- bquote(b <- sum(a, a))
print(expr_b)
print(class(expr_b))

# Creating a chunk by call -------------------------------
expr_c <- call("sum", a, a)
print(expr_c)
print(class(expr_c))
```

To evaluate the expressions of class `call` or an assignment given by class `<-` above, R uses the `eval` function. This function evaluates each single `call` inside the current environment, in case no other environment is given. In the example code you can see what happens upon evaluating the expressions:

```{r}
a <- 3
expr_a <- quote(sum(a, a))
expr_b <- bquote(b <- a + a)
expr_c <- call("sum", a, a)

eval(expr_a)
eval(expr_b)
print(b)
eval(expr_c)
```

Now `chunk` objects can be created and evaluated using the expressions above as follows:
```{r}
chunk_1 <- teal.code::chunk$new(expression = expr_a)
chunk_1$eval()

chunk_2 <- teal.code::chunk$new(expression = expr_b)
chunk_2$eval()
print(b)

chunk_3 <- teal.code::chunk$new(expression = expr_c)
chunk_3$eval()
```
Note that `teal.code::chunk` is merely an alias for `teal.code::chunk_call`. And so the following code is the same as the above code:
```{r}
chunk_1 <- teal.code::chunk_call$new(expression = expr_a)
chunk_1$eval()

chunk_2 <- teal.code::chunk_call$new(expression = expr_b)
chunk_2$eval()
print(b)

chunk_3 <- teal.code::chunk_call$new(expression = expr_c)
chunk_3$eval()
```

## Motivation for the chunk (chunk_call) object

A quoted R expression can simply be evaluated with the base function, `eval`, as demonstrated above. But additional functionalities are needed for the `chunks` container to work. Here are some additional methods, besides `eval`, that the `chunk` object contains:

```{r}
# answers the question of whether the code executed without error
chunk_1$is_ok()

# answers the question of whether the code has been executed
chunk_1$is_evaluated()

# returns error messages, if any, in the form of a string
chunk_err <- teal.code::chunk_call$new(expression = quote(stop("error in chunk")))
chunk_err$get_errors() # no error before evaluation
chunk_err$eval()
chunk_err$get_errors()
```

Internally, the `chunks` container will convert quoted R expressions into `chunk` objects as they are pushed in.


The next sections will tell in a step by step guide which features are provided by the `chunks` container object.

# Step by step to understand chunks container

## General information

Normally as a module developer the chunks container will be used within the `server` function of a shiny/teal module. To create a chunks container object, call the R6 class `new` method:

```{r}
# initializing code chunks -------------------------------------------
chunks_container <- teal.code::chunks$new()
```

## Feature 1: Reset (initialize the environment)

Normally reproducible code will be used inside a `renderPlot` or `renderTable` call of a shiny module. For simplicity reasons we just use the *pseudo* shiny session defined above in this tutorial. As a first step the chunks container should be handed over an analysis dataset (`anl`) and two variables `x = "abc"`, `y = 5`. Therefore you need to use the `teal.code::chunks_reset` function. It not only empties all current chunks inside the container, but also hands over all variables from the current environment to the container environment.

To check that it worked as expected the function `teal.code::chunks_get_var` will be used and check that the values inside the chunks container are equal to the values from the environment.

You can use this code snippet:

```{r}
# Adding variables to the chunks container -------------------------------------
anl <- data.frame(left = c(1, 2, 3), right = c(4, 5, 6))
x <- "abc"
y <- 5

teal.code::chunks_reset(chunks = chunks_container)

# Double check variables were handed over-----------------------------
all.equal(x, teal.code::chunks_get_var("x", chunks = chunks_container))
```

<img src="images/reset.png" alt="reset" style="width: 100%;"/>


## Feature 2: Push - adding code snippets

To populate the chunks container, a chunk can be added using the `teal.code::chunks_push` function. Here two code snippets will be added:

```{r}
teal.code::chunks_push(bquote(y <- y + 1), chunks = chunks_container)
teal.code::chunks_push(bquote(x <- paste0(x, y)), chunks = chunks_container)
```

<img src="images/push.png" alt="push" style="width: 100%;"/>

## Feature 3: Get R code - showing the chunks container code

To reproduce what was done inside the chunks container, it is necessary to render the R code inside them. Therefore the chunks container can display all its code by calling `teal.code::chunks_get_rcode`. You can run this example to see the code:

```{r}
teal.code::chunks_get_rcode(chunks_container)
```
<img src="images/get_rcode.png" alt="get_rcode" style="width: 100%;"/>

## Feature 4: `eval` - evaluating the code

The `eval` function is responsible to run the code inside the chunks container. The `eval` function of a chunks container is called `teal.code::chunks_safe_eval`. It evaluates all chunks inside the container in the order they were pushed. It is not possible to change the order or run just pieces of the code.

The `teal.code::chunks_safe_eval` will always return the value of the last evaluation. By `teal.code::chunks_get_var` it is possible to retrieve specific variables after evaluation.

```{r}
teal.code::chunks_safe_eval(chunks_container)
teal.code::chunks_get_var("x", chunks = chunks_container)
teal.code::chunks_get_var("y", chunks = chunks_container)
```

<img src="images/eval.png" alt="eval" style="width: 100%;"/>

## Feature 5: Is ok - check for errors and warnings

A chunks container object also has its own `eval` method. The function `teal.code::chunks_safe_eval` is merely a wrapper of this method. It is named `"safe_eval"` because it performs an additional step to handle errors by calling another method of the chunks container object, `validate_is_ok`. If any error occurs during the evaluation of expressions pushed into the chunks container, the error is handled and stored in the `chunk` object that contains the expression, and thus no error is thrown to the calling environment.

The most important function to check if everything went fine is `teal.code::chunks_is_ok`. It will return `TRUE` in the case where everything was fine.

`teal.code::chunks_validate_is_ok` returns a useful `validate(need(...))` message inside the shiny app in case something went wrong.

```{r, error=TRUE}
teal.code::chunks_is_ok(chunks_container)
teal.code::chunks_validate_is_ok(chunks = chunks_container)

# Trying an error inside a chunk ------------------------
teal.code::chunks_push(quote(stop("ERROR")), chunks = chunks_container)
teal.code::chunks_safe_eval(chunks_container)

teal.code::chunks_is_ok(chunks_container)

teal.code::chunks_validate_is_ok(chunks = chunks_container)
```

<img src="images/is_ok.png" alt="is_ok" style="width: 100%;"/>

The use of the `teal.code::chunks_safe_eval` is extremely important in a reactive context, such as inside the server function of a shiny app. Since errors are not thrown to the environment calling the chunks container, it will not crash the shiny app, which is a good thing. However, the shiny app will also not know that an error has occurred. Calling `teal.code::chunks_safe_eval` instead of the `eval` method of the chunks container ensures that a validation step occurs.

## Tutorial Summary

In summary:

1. chunks containers host code snippets
2. chunks containers host their own environment
3. chunks container can be accessed to retrieve variables from the environment using `teal.code::chunks_get_var`
4. expressions can be added to the chunks container by `teal.code::chunks_push`
5. code inside a container can be executed by `teal.code::chunks_safe_eval`
6. `teal.code::chunks_validate_is_ok` and `teal.code::chunks_is_ok` allow checking for execution errors

The whole implementation of this tutorial is given in the *gif* below:

<img src="images/chunks_animation.gif" alt="chunks_animation" style="width: 100%;"/>


For more information about the implementation of chunks inside of shiny/teal module, please visit the Advanced chunks article.

Please find below the implicit vs. explicit usage of code chunks containers.
