% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/qenv-constructor.R, R/qenv-eval_code.R,
%   R/qenv-get_code.R, R/qenv-within.R
\name{qenv}
\alias{qenv}
\alias{eval_code}
\alias{eval_code,qenv,character-method}
\alias{eval_code,qenv,language-method}
\alias{eval_code,qenv,expression-method}
\alias{eval_code,qenv.error,ANY-method}
\alias{qenv-inheritted}
\alias{get_code}
\alias{get_code,qenv-method}
\alias{get_code,qenv.error-method}
\alias{within.qenv}
\title{Code tracking with \code{qenv} object}
\usage{
qenv()

eval_code(object, code)

x[[name]]
x$name
names(x)
ls(name, pos = -1L, envir = as.environment(pos),
   all.names = FALSE, pattern, sorted = TRUE)

get_code(object, deparse = TRUE, names = NULL, ...)

\method{within}{qenv}(data, expr, ...)
}
\arguments{
\item{object}{(\code{qenv})}

\item{code}{(\code{character} or \code{language}) code to evaluate. If \code{character}, comments are retained.}

\item{deparse}{(\code{logical(1)}) flag specifying whether to return code as \code{character} or \code{expression}.}

\item{names}{\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#experimental}{\figure{lifecycle-experimental.svg}{options: alt='[Experimental]'}}}{\strong{[Experimental]}} (\code{character}) vector of object names to return the code for.
For more details see the "Extracting dataset-specific code" section.}

\item{...}{see \code{Details}}

\item{data}{(\code{qenv})}

\item{expr}{(\code{expression}) to evaluate. Must be inline code, see \verb{Using language objects...}}

\item{x}{(\code{qenv}) object.}

\item{name}{(\code{character}) name of object.}

\item{pos, envir, all.names, pattern, sorted}{see \code{\link[=ls]{ls()}} function for details.}
}
\value{
Returns a \code{qenv} object.

\code{eval_code} returns a \code{qenv} object with \code{expr} evaluated or \code{qenv.error} if evaluation fails.

\code{[[}, \code{$} and \code{get} return the value of the object named \code{name} in the \code{qenv} object.

\code{names} return a character vector of all the names of the objects in the \code{qenv} object.

\code{ls} return a character vector of the names of the objects in the \code{qenv} object.
It will only show the objects that are not named with a dot prefix, unless
the \code{all.names = TRUE}, which will show all objects.

\code{get_code} returns the traced code (from \verb{@code} slot) in the form specified by \code{deparse}.

\code{within} returns a \code{qenv} object with \code{expr} evaluated or \code{qenv.error} if evaluation fails.
}
\description{
\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#stable}{\figure{lifecycle-stable.svg}{options: alt='[Stable]'}}}{\strong{[Stable]}}

Create a \code{qenv} object and evaluate code in it to track code history.
}
\details{
\code{qenv()} instantiates a \code{qenv} with an empty environment.
Any changes must be made by evaluating code in it with \code{eval_code} or \code{within}, thereby ensuring reproducibility.

\code{eval_code} evaluates given code in the \code{qenv} environment and appends it to the \code{code} slot.
Thus, if the \code{qenv} had been instantiated empty, contents of the environment are always a result of the stored code.

\code{x[[name]]}, \code{x$name} and \code{get(name, x)} are generic \R operators to access the objects in the environment.
See [\code{[[}] for more details.
\code{names(x)} and \code{ls(x)} calls on the \code{qenv} object and will list all objects in the environment.

\code{get_code()} retrieves the code stored in the \code{qenv}. \code{...} passes arguments to methods.

\code{within()} is a convenience function for evaluating inline code inside the environment of a \code{qenv}.
It is a method for the \code{base} generic that wraps \code{eval_code} to provide a simplified way of passing code.
\code{within} accepts only inline expressions (both simple and compound) and allows for injecting values into \code{expr}
through the \code{...} argument:
as \code{name:value} pairs are passed to \code{...}, \code{name} in \code{expr} will be replaced with \code{value}.
}
\section{Extracting objects from \code{qenv}}{


Extracting an object from the \code{qenv} by name can be done using the following methods:
\itemize{
\item \code{x[[name]]}
\item \code{x$name}
\item \code{get(name, envir = x)}
}

note: \code{get_var(name)} was superseded by the native \R methods above.

To list all objects in the environment, use \code{ls(x)} (which doesn't show
objects that have a dot prefix with default arguments) or \code{names(x)} (shows all objects).
}

\section{Environment}{


The \code{qenv} object behaves like an environment that is locked and one can use
some of the \code{base} functions dedicated to the \code{environment}. List of supported
functions includes:
\code{names()}, \code{ls()}, \code{get()}, \code{exists()}, \code{parent.env()}, \code{lapply}, \code{sapply}
\code{vapply}, \code{local}, \code{as.environment()}, \code{is.environment()}, \code{as.list()}, ...
We don't recommend using any function outside of the \code{teal.code} exports and these
mentioned above.
}

\section{Extracting dataset-specific code}{

When \code{names} is specified, the code returned will be limited  to the lines needed to \emph{create}
the requested objects. The code stored in the \verb{@code} slot is analyzed statically to determine
which lines the objects of interest depend upon. The analysis works well when objects are created
with standard infix assignment operators (see \code{?assignOps}) but it can fail in some situations.

Consider the following examples:

\emph{Case 1: Usual assignments.}

\if{html}{\out{<div class="sourceCode r">}}\preformatted{q1 <- qenv() |>
  within(\{
    foo <- function(x) \{
      x + 1
    \}
    x <- 0
    y <- foo(x)
  \})
get_code(q1, names = "y")
}\if{html}{\out{</div>}}

\code{x} has no dependencies, so \code{get_code(data, names = "x")} will return only the second call.\cr
\code{y} depends on \code{x} and \code{foo}, so \code{get_code(data, names = "y")} will contain all three calls.

\emph{Case 2: Some objects are created by a function's side effects.}

\if{html}{\out{<div class="sourceCode r">}}\preformatted{q2 <- qenv() |>
  within(\{
    foo <- function() \{
      x <<- x + 1
    \}
    x <- 0
    foo()
    y <- x
  \})
get_code(q2, names = "y")
}\if{html}{\out{</div>}}

Here, \code{y} depends on \code{x} but \code{x} is modified by \code{foo} as a side effect (not by reassignment)
and so \code{get_code(data, names = "y")} will not return the \code{foo()} call.\cr
To overcome this limitation, code dependencies can be specified manually.
Lines where side effects occur can be flagged by adding "\verb{# @linksto <object name>}" at the end.\cr
Note that \code{within} evaluates code passed to \code{expr} as is and comments are ignored.
In order to include comments in code one must use the \code{eval_code} function instead.

\if{html}{\out{<div class="sourceCode r">}}\preformatted{q3 <- qenv() |>
  eval_code("
    foo <- function() \{
      x <<- x + 1
    \}
    x <- 0
    foo() # @linksto x
    y <- x
  ")
get_code(q3, names = "y")
}\if{html}{\out{</div>}}

Now the \code{foo()} call will be properly included in the code required to recreate \code{y}.

Note that two functions that create objects as side effects, \code{assign} and \code{data}, are handled automatically.

Here are known cases where manual tagging is necessary:
\itemize{
\item non-standard assignment operators, \emph{e.g.} \verb{\%<>\%}
\item objects used as conditions in \code{if} statements: \verb{if (<condition>)}
\item objects used to iterate over in \code{for} loops: \verb{for(i in <sequence>)}
\item creating and evaluating language objects, \emph{e.g.} \verb{eval(<call>)}
}
}

\section{Using language objects with \code{within}}{

Passing language objects to \code{expr} is generally not intended but can be achieved with \code{do.call}.
Only single \code{expression}s will work and substitution is not available. See examples.
}

\examples{
# create empty qenv
qenv()

# evaluate code in qenv
q <- qenv()
q <- eval_code(q, "a <- 1")
q <- eval_code(q, quote(library(checkmate)))
q <- eval_code(q, expression(assert_number(a)))

# Extract objects from qenv
q[["a"]]
q$a

# list objects in qenv
names(q)
# retrieve code
q <- within(qenv(), {
  a <- 1
  b <- 2
})
get_code(q)
get_code(q, deparse = FALSE)
get_code(q, names = "a")

q <- qenv()
q <- eval_code(q, code = c("a <- 1", "b <- 2"))
get_code(q, names = "a")

# evaluate code using within
q <- qenv()
q <- within(q, {
  i <- iris
})
q <- within(q, {
  m <- mtcars
  f <- faithful
})
q
get_code(q)

# inject values into code
q <- qenv()
q <- within(q, i <- iris)
within(q, print(dim(subset(i, Species == "virginica"))))
within(q, print(dim(subset(i, Species == species)))) # fails
within(q, print(dim(subset(i, Species == species))), species = "versicolor")
species_external <- "versicolor"
within(q, print(dim(subset(i, Species == species))), species = species_external)

# pass language objects
expr <- expression(i <- iris, m <- mtcars)
within(q, expr) # fails
do.call(within, list(q, expr))

exprlist <- list(expression(i <- iris), expression(m <- mtcars))
within(q, exprlist) # fails
do.call(within, list(q, do.call(c, exprlist)))

}
\seealso{
\code{\link[base:with]{base::within()}}, \code{\link[=get_var]{get_var()}}, \code{\link[=get_env]{get_env()}}, \code{\link[=get_warnings]{get_warnings()}}, \code{\link[=join]{join()}}, \code{\link[=concat]{concat()}}
}
