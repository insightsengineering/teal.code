#' Reproducible class with environment and code.
#'
#' Reproducible class with environment and code.
#' @name Quosure-class
#' @rdname Quosure-class
#' @slot code (`character`) to reproduce the environment
#' @slot env (`environment`) environment which content was generated by the evaluation
#'  of the `code` slot.
#' @slot id (`integer`) random identifier of the code element to make sure uniqueness
#'  when joining.
#' @keywords internal
setClass(
  "Quosure",
  slots = c(env = "environment", code = "character", id = "integer"),
  prototype = list(env = new.env(parent = parent.env(.GlobalEnv)), code = character(0), id = integer(0))
)

#' It takes a `Quosure` class and returns TRUE if the input is valid
#' @keywords internal
setValidity("Quosure", function(object) {
  if (length(object@code) != length(object@id)) {
    "@code and @id slots must have the same length."
  } else if (any(duplicated(object@id))) {
    "@id contains duplicated values."
  } else {
    TRUE
  }
})

#' Initialize `Quosure` object
#'
#' Initialize `Quosure` object with `code` and `env`. In order to have `Quosure` reproducible
#' one needs to initialize with `env` which can be reproduced by the `code`. Alternatively, one
#' can create an empty `Quosure` and evaluate the expressions in this object.
#' @name new_quosure
#'
#' @param code (`character(1)` or `language`) code to evaluate. Accepts and stores comments also.
#' @param env (`environment`) Environment being a result of the `code` evaluation.
#'
#' @export
setGeneric("new_quosure", function(env = new.env(parent = parent.env(.GlobalEnv)), code = character(0)) {
  standardGeneric("new_quosure")
})

#' @rdname new_quosure
#' @export
setMethod(
  "new_quosure",
  signature = c(env = "environment", code = "character"),
  function(env, code) {
    lockEnvironment(env)

    if (is.null(names(code)) && length(code)) {
      names(code) <- make.unique(rep("initial code", length(code)))
    }

    code <- .keep_code_name_unique(code)
    id <- sample.int(.Machine$integer.max, size = length(code))

    methods::new("Quosure", env = env, code = code, id = id)
  }
)

#' @rdname new_quosure
#' @export
setMethod(
  "new_quosure",
  signature = c(env = "environment", code = "expression"),
  function(env, code) {
    code_char <- as.character(code)
    new_quosure(env = env, code = code_char)
  }
)

#' @rdname new_quosure
#' @export
setMethod(
  "new_quosure",
  signature = c(env = "environment", code = "language"),
  function(env, code) {
    code_expr <- as.expression(code)
    new_quosure(env = env, code = code_expr)
  }
)

#' @rdname new_quosure
#' @export
setMethod(
  "new_quosure",
  signature = c(env = "environment", code = "ANY"),
  function(env, code) {
    quoted_expr <- substitute(code)
    new_quosure(env = env, code = quoted_expr)
  }
)

#' @rdname new_quosure
#' @export
setMethod(
  "new_quosure",
  signature = c(env = "list"),
  function(env, code) {
    if (!missing(code)) {
      warning(
        "`code` argument is ignored when creating Quosure from the list.",
        "\nPlease pass the code througn attr(<list>, 'code')"
      )
    }

    code <- attr(env, "code") # named
    if (length(code) == 0) {
      stop("To create the Quosure from the list it must contain 'code' attribute.")
    }

    if (checkmate::test_list(env, "reactive")) {
      env <- lapply(env, function(x) {
        if (inherits(x, "reactive")) {
          x()
        } else {
          x
        }
      })
    }
    new_quosure(env = list2env(env), code = code)
  }
)

#' @rdname new_quosure
#' @export
setMethod(
  "new_quosure",
  signature = c(code = "missing", env = "missing"),
  function(env, code) {
    new_quosure(env = env, code = code)
  }
)

#' Evaluate the code in the `Quosure` environment
#'
#' Given code is evaluated in the `Quosure` environment and appended to the `code` slot. This means
#' that state of the environment is always a result of the stored code (if `Quosure` was initialized)
#' with reproducible code.
#'
#' @name eval_code
#'
#' @param object (`Quosure`)
#' @param code (`character` or `language`) code to evaluate. Also accepts and stores comments
#' @param name (`character(1)`) name of the code block.
#'
#' @export
setGeneric("eval_code", function(object, code, name = "code") {
  standardGeneric("eval_code")
})

#' @rdname eval_code
#' @export
setMethod(
  "eval_code",
  signature = c("Quosure", "character"),
  function(object, code, name) {
    checkmate::assert_character(name, len = 1L)
    if (is.null(names(code))) {
      code <- paste(code, collapse = "\n")
      names(code) <- name
    }
    id <- sample.int(.Machine$integer.max, size = length(code))
    object@id <- c(object@id, id)
    object@code <- .keep_code_name_unique(object@code, code)

    # need to copy the objects from old env to new env
    # to avoid updating environments in the separate objects
    object@env <- .copy_env(object@env)
    eval(parse(text = code), envir = object@env)
    lockEnvironment(object@env)
    object
  }
)

#' @rdname eval_code
#' @export
setMethod(
  "eval_code",
  signature = c("Quosure", "expression"),
  function(object, code, name) {
    code_char <- as.character(code)
    eval_code(object, code_char, name = name)
  }
)

#' @rdname eval_code
#' @export
setMethod(
  "eval_code",
  signature = c("Quosure", "language"),
  function(object, code, name) {
    code_char <- as.expression(code)
    eval_code(object, code_char, name = name)
  }
)

#' @rdname eval_code
#' @export
setMethod(
  "eval_code",
  signature = c("Quosure", "ANY"),
  function(object, code, name) {
    code_expr <- substitute(code)
    eval_code(object, code_expr, name = name)
  }
)

#' Get object from the `Quosure` environment
#'
#' Get object from the `Quosure` environment.
#' @param object (`Quosure`)
#' @param var (`character(1)`) name of the variable to pull from the environment.
#' @name get_var
#' @export
setGeneric("get_var", function(object, var) {
  standardGeneric("get_var")
})


#' @rdname get_var
#' @export
setMethod("get_var", signature = c("Quosure", "character"), function(object, var) {
  get(var, envir = object@env)
})

#' @param x (`Quosure`)
#' @param i (`character`) name of the binding in environment (name of the variable)
#' @param j not used
#' @param ... not used
#' @rdname get_var
#' @export
setMethod("[[", c("Quosure", "ANY", "missing"), function(x, i, j, ...) {
  get_var(x, i)
})

#' Get code from `Quosure`
#'
#' @param object (`Quosure`)
#' @return named `character` with the reproducible code.
#' @export
setGeneric("get_code", function(object) {
  standardGeneric("get_code")
})

#' Get the code from the `Quosure`
#'
#' @param object (`Quosure`)
setMethod("get_code", signature = "Quosure", function(object) {
  object@code
})

#' Join two `Quosure` objects
#'
#' Combine two `Quosure` object by merging their environments and the code.
#' Not every `Quosure` objects can be combined:
#' - if their environments contains objects of the same name but not identical
#' - if `y` has unique code element placed before common element. This means that `y`
#' in the environment of the `y` was evaluated some extra code before which can influence
#' reproducibility
#' - more cases to be done
#' @param x (`Quosure`)
#' @param y (`Quosure`)
#' @export
setGeneric("join", function(x, y) {
  standardGeneric("join")
})

#' @rdname join
#' @export
setMethod("join", signature = c("Quosure", "Quosure"), function(x, y) {
  join_validation <- check_joinable(x, y)

  # join expressions
  if (!isTRUE(join_validation)) {
    stop(join_validation)
  }

  id_unique <- !y@id %in% x@id
  x@id <- c(x@id, y@id[id_unique])
  x@code <- .keep_code_name_unique(x@code, y@code[id_unique])

  # insert (and overwrite) objects from env2 to env
  x@env <- .copy_env(x@env)
  lapply(ls(y@env), function(xx) assign(xx, get(xx, y@env), x@env))

  x
})

#' If two `Quosure` can be joined
#'
#' Checks if two `Quosure` objects can be combined.
#' They can't be combined if (and):
#' - both share the same code (identified by `id`)
#' - indices of the shared code are not consecutive or don't start from 1
#' @param x (`Quosure`)
#' @param y (`Quosure`)
#' @return `TRUE` if able to join or `character` used to print error message.
#' @keywords internal
check_joinable <- function(x, y) {
  checkmate::assert_class(x, "Quosure")
  checkmate::assert_class(y, "Quosure")

  common_names <- intersect(ls(x@env), ls(y@env))
  is_overwritten <- vapply(common_names, function(el) {
    !identical(get(el, x@env), get(el, y@env))
  }, logical(1))
  if (any(is_overwritten)) {
    return(
      paste(
        "Not possible to join Quosure objects if anything in their environment has been modified.\n",
        "Following object(s) have been modified:\n - ",
        paste(common_names[is_overwritten], collapse = "\n - ")
      )
    )
  }

  shared_ids <- intersect(x@id, y@id)
  if (length(shared_ids) == 0) {
    return(TRUE)
  }

  shared_in_x <- match(shared_ids, x@id)
  shared_in_y <- match(shared_ids, y@id)

  # indices of shared ids should be 1:n in both slots
  if (identical(shared_in_x, shared_in_y) && identical(shared_in_x, seq_along(shared_ids))) {
    TRUE
  } else if (!identical(shared_in_x, shared_in_y)) {
    paste(
      "The common code of joined objects doesn't have the same indices. It means that `x` and `y`",
      "can't be joined together as it's impossible to determine the evaluation's order.",
      collapse = ""
    )
  } else {
    paste(
      "The common code of joined object does not start from index = 1.",
      "It means that joined object(x) has some extra code elements before.",
      collapse = ""
    )
  }
}

#' Copy environment content to the other environment
#' To avoid sharing the same environment by multiple `Quosure` objects
#' @keywords internal
.copy_env <- function(env) {
  # need to copy the objects from old env to new env
  # to avoid "chunks" sharing the same environment
  env_new <- new.env()
  for (i in ls(env)) {
    env_new[[i]] <- env[[i]]
  }
  env_new
}

.keep_code_name_unique <- function(x, y = character(0)) {
  combined <- c(x, y)
  if (length(names(combined)) == 0) {
    return(combined)
  }
  setNames(combined, make.unique(names(combined)))
}
