#' Reproducible class with environment and code.
#'
#' @slot code (`character`) to reproduce the environment
#' @slot env (`environment`) environment which content was generated by the evaluation
#' of the `code` slot.
setClass(
  "Quosure",
  representation(env = "environment", code = "character"),
  prototype(env = new.env(parent = parent.env(.GlobalEnv)), code = character(0))
)

#' Initialize `Quosure` object
#'
#' Initialize `Quosure` object with `code` and `env`. In order to have `Quosure` reproducible
#' one needs to initialize with `env` which can be reproduced by the `code`. Alternatively, one
#' can create an empty `Quosure` and evaluate the expressions in this object.
#' @name new_quosure
#'
#' @param code (`character(1)` or `language`) code to evaluate. Accepts and stores comments also.
#' @param env (`environment`) Environment being a result of the `code` evaluation.
#'
#' @export
setGeneric("new_quosure", function(env = new.env(parent = parent.env(.GlobalEnv)), code = character(0)) {
  standardGeneric("new_quosure")
})

#' @rdname new_quosure
#' @export
setMethod(
  "new_quosure", signature(env = "environment", code = "character"),
  function(env, code) {
    lockEnvironment(env)

    if (is.null(names(code)) && length(code)) {
      names(code) <- make.unique(rep("code", length(code)))
    }
    methods::new("Quosure", env = env, code = code)
  }
)

#' @rdname new_quosure
#' @export
setMethod(
  "new_quosure", signature(env = "environment", code = "language"),
  function(env, code) {
    code_expr <- as.expression(code)
    new_quosure(env = env, code = code_expr)
  }
)

#' @rdname new_quosure
#' @export
setMethod(
  "new_quosure", signature(env = "environment", code = "expression"),
  function(env, code) {
    code_char <- as.character(code)
    new_quosure(env = env, code = code_char)
  }
)

#' @rdname new_quosure
#' @export
setMethod(
  "new_quosure", signature(env = "environment", code = "ANY"),
  function(env, code) {
    quoted_expr <- substitute(code)
    new_quosure(env = env, code = quoted_expr)
  }
)

#' @rdname new_quosure
#' @export
setMethod(
  "new_quosure", signature(env = "list"),
  function(env, code = attr(env, "code")) {
    if (missing(code)) {
      code <- attr(env, "code")
    }
    if (checkmate::test_list(env, "reactive")) {
      env <- lapply(env, function(x) {
        if (inherits(x, "reactive")) {
          x()
        } else {
          x
        }
      })
    }
    eval(substitute(
      new_quosure(env = list2env(env), code = code),
      list(code = substitute(code))

    ))
  }
)

#' @rdname new_quosure
#' @export
setMethod(
  "new_quosure", signature(code = "missing", env = "missing"),
  function(env, code) {
    new_quosure(env = env, code = code)
  }
)

#' Evaluate the code in the `Quosure` environment
#'
#' Given code is evaluated in the `Quosure` environment and appended to the `code` slot. This means
#' that state of the environment is always a result of the stored code (if `Quosure` was initialized)
#' with reproducible code.
#'
#' @name eval_code
#'
#' @param object (`Quosure`)
#' @param code (`character` or `language`) code to evaluate. Also accepts and stores comments
#' @param name (`character(1)`) name of the code block.
#'
#' @export
setGeneric("eval_code", function(object, code, name = "code") {
  standardGeneric("eval_code")
})

#' @rdname eval_code
#' @export
setMethod(
  "eval_code", signature("Quosure", "character"),
  function(object, code, name = "code") {
    checkmate::assert_character(name, len = 1L)
    code <- paste(code, collapse = "\n")
    names(code) <- name
    object@code <- .keep_code_name_unique(object@code, code) # combine code vector (and make names unique)

    # need to copy the objects from old env to new env
    # to avoid updating environments in the separate objects
    object@env <- .copy_env(object@env)
    eval(parse(text = code), envir = object@env)
    lockEnvironment(object@env)
    object
  }
)

#' @rdname eval_code
#' @export
setMethod(
  "eval_code", signature("Quosure", "language"),
  function(object, code, name = "code") {
    code_char <- as.expression(code)
    eval_code(object, code_char, name = name)
  }
)

#' @rdname eval_code
#' @export
setMethod(
  "eval_code", signature("Quosure", "ANY"),
  function(object, code, name = "code") {
    code_expr <- substitute(code)
    eval_code(object, code_expr, name = name)
  }
)


#' @rdname eval_code
#' @export
setMethod(
  "eval_code", signature("Quosure", "expression"),
  function(object, code, name = "code") {
    code_char <- as.character(code)
    eval_code(object, code_char, name = name)
  }
)

#' Get object from the `Quosure` environment
#'
#' Get object from the `Quosure` environment.
#' @param object (`Quosure`)
#' @param var (`character(1)`) name of the variable to pull from the environment.
#' @name get_var
#' @export
setGeneric("get_var", function(object, var) {
  standardGeneric("get_var")
})


#' @rdname get_var
#' @export
setMethod("get_var", signature("Quosure", "character"), function(object, var) {
  get(var, envir = object@env)
})

#' @param x (`Quosure`)
#' @param i (`character`) name of the binding in environment (name of the variable)
#' @param j not used
#' @param ... not used
#' @rdname get_var
#' @export
setMethod("[[", c("Quosure", "ANY", "missing"), function(x, i, j, ...) {
  get_var(x, i)
})


#' Get code from `Quosure`
#'
#' @param object (`Quosure`)
#' @return named `character` with the reproducible code.
#' @export
setGeneric("get_code", function(object) {
  standardGeneric("get_code")
})

#' Get the code from the `Quosure`
#'
#' @param object (`Quosure`)
setMethod("get_code", signature("Quosure"), function(object) {
  object@code
})

#' Join two `Quosure` objects
#'
#' Combine two `Quosure` object by merging their environments and the code.
#' Not every `Quosure` objects can be combined:
#' - if their environments contains objects of the same name but not identical
#' - if `object2` has unique code element placed before common element. This means that `object2`
#' in the environment of the `object2` was evaluated some extra code before which can influence
#' reproducibility
#' - more cases todo
#' @param object (`Quosure`)
#' @param object2 (`Quosure`)
#' @export
setGeneric("join", function(object, object2) {
  standardGeneric("join")
})

setMethod("join", signature("Quosure", "Quosure"), function(object, object2) {
  # todo: revise chunks_merge_chunks and make robust join method

  # object2 can't have modified object of the same name! See chunks_push_chunks
  common_names <- intersect(ls(object@env), ls(object2@env))
  is_overwritten <- vapply(common_names, function(x) {
    !identical(get(x, object@env), get(x, object2@env))
  }, logical(1))

  # code
  a_is_shared_code <- object@code %in% object2@code
  b_is_shared_code <- object2@code %in% object@code

  if (
    any(a_is_shared_code) &&
    (isFALSE(a_is_shared_code[1]) || isFALSE(b_is_shared_code[1]))
  ) {
    stop(
      "`object` and `object2` can't be joined if one of the objects contains extra code before ",
      "code shared by both."
    )
  } else if (
    any(a_is_shared_code) && any(b_is_shared_code) &&
    any(!a_is_shared_code) && any(!b_is_shared_code) &&
    any(is_overwritten)) {
    stop(
      "`object` and `object2` have an extra code and environments contains modified object(s) of the same name ",
      "Following object(s) have been modified:\n - ",
      paste(common_names[is_overwritten], collapse = "\n - ")
    )
  }

  # join expressions
  # - remove duplicated code from object2 and append to the object1
  unique_expr <- object2@code[!(object2@code %in% object@code & names(object2@code) %in% names(object@code))]
  # - in case object@code and object2@code contains extra code with the same name - code2 needs to be renamed
  object@code <- .keep_code_name_unique(object@code, unique_expr)

  # insert (and overwrite) objects from env2 to env
  object@env <- .copy_env(object@env)
  lapply(ls(object2@env), function(x) assign(x, get(x, object2@env), object@env))

  object
})

#' Copy environment content to the other environment
#' To avoid sharing the same environment by multiplequo object (in reactives)
#' @keywords internal
.copy_env <- function(env) {
  # need to copy the objects from old env to new env
  # to avoid "chunks" sharing the same environment
  env_new <- new.env()
  for (i in ls(env)) {
    env_new[[i]] <- env[[i]]
  }
  env_new
}

.keep_code_name_unique <- function(x, y) {
  nm <- make.unique(c(names(x), names(y)))
  setNames(c(x, y), nm)
}


reactive_quosure <- function(depends, expr) {
  reactive(expr, env = depends()@env)
}


#' @export
as_quosure <- function(x) {
  UseMethod("as_quosure")
}

#' @export
as_quosure.list <- function(x) {
  new_quosure(list2env(x), code = as.expression(attr(x, "code")))
}
