#' Reproducible class with environment and code.
#'
#' @slot code (`character`) to reproduce the environment
#' @slot env (`environment`) environment which content was generated by the evaluation
#' of the `code` slot.
setClass(
  "Quosure",
  representation(code = "character", env = "environment"),
  prototype(code = character(0), env = new.env(parent = parent.env(.GlobalEnv)))
)

#' Initialize `Quosure` object
#'
#' Initialize `Quosure` object with `code` and `env`. In order to have `Quosure` reproducible
#' one needs to initialize with `env` which can be reproduced by the `code`. Alternatively, one
#' can create an empty `Quosure` and evaluate the expressions in this object.
#' @name new_quosure
#'
#' @param code (`character(1)` or `language`) code to evaluate. Also acceptps and stores comments
#' @param env (`environment`) name of the code element.
#'
#' @export
setGeneric("new_quosure", function(code = character(0), env = parent.env(.GlobalEnv)) {
  standardGeneric("new_quosure")
})

#' @rdname new_quosure
#' @export
setMethod(
  "new_quosure", signature(code = "missing", env = "missing"),
  function(code, env) {
    methods::new("Quosure")
  }
)

#' @rdname new_quosure
#' @export
setMethod(
  "new_quosure", signature(code = "character"),
  function(code = character(0), env = parent.env(.GlobalEnv)) {
    checkmate::check_class(env, "environment")
    checkmate::check_string(code)

    lockEnvironment(env)

    if (is.null(names(code))) {
      names(code) <- "code"
    }
    methods::new("Quosure", code = code, env = env)
  }
)

setGeneric("get_code", function(object, deparse = FALSE) {
  standardGeneric("get_code")
})

setGeneric("join", function(object, object2, overwrite = FALSE) {
  standardGeneric("join")
})

#' Evaluate the code in the `Quosure` environment
#'
#' Given code is evaluated in the `Quosure` environment and appended to the `code` slot. This means
#' that state of the environment is always a result of the stored code (if `Quosure` was initialized)
#' with reproducible code.
#'
#' @name eval_code
#'
#' @param object (`Quosure`)
#' @param code (`character(1)` or `language`) code to evaluate. Also acceptps and stores comments
#' @param name (`character(1)`) name of the code element.
#'
#' @export
setGeneric("eval_code", function(object, code, name = "code") {
  standardGeneric("eval_code")
})

#' @rdname eval_code
#' @export
setMethod(
  "eval_code", signature("Quosure", "character"),
  function(object, code, name = "code") {
    # combine code vector (and make names unique)
    nm <- make.unique(c(names(object@code), name))
    object@code <- setNames(c(object@code, code), nm)

    # need to copy the objects from old env to new env
    # to avoid "chunks" sharing the same environment
    object@env <- .copy_env(object@env)
    eval(parse(text = code), envir = object@env)
    lockEnvironment(object@env)
    object
  }
)

#' @rdname eval_code
#' @export
setMethod(
  "eval_code", signature("Quosure", "language"),
  function(object, code, name = "code") {
    code_char <- deparse1(code)
    eval_code(object, code_char, name = name)
  }
)

#' @rdname eval_code
#' @export
setMethod(
  "eval_code", signature("Quosure", "expression"),
  function(object, code, name = "code") {
    code_char <- as.character(code)
    eval_code(object, code_char, name = name)
  }
)

#' Get object from the `Quosure` environment
#'
#' Get object from the `Quosure` environment.
#' @param object (`Quosure`)
#' @param var (`character(1)`) name of the variable to pull from the environment.
#' @name get_var
#' @export
setGeneric("get_var", function(object, var) {
  standardGeneric("get_var")
})


#' @rdname get_var
#' @export
setMethod("get_var", signature("Quosure", "character"), function(object, var) {
  get(var, envir = object@env)
})

#' @param x (`Quosure`)
#' @param i (`character`) name of the binding in environment (name of the variable)
#' @param j not used
#' @param ... not used
#' @rdname get_var
#' @export
setMethod("[[", c("Quosure", "ANY", "missing"), function(x, i, j, ...) {
  get_var(x, i)
})


#' Get the code from the `Quosure`
#'
#' @param object (`Quosure`)
setMethod("get_code", signature("Quosure"), function(object) {
  object@code
})


#' Join two `Quosure` objects
#'
#' Combine two `Quosure` object by merging their environments and the code.
#' Not every `Quosure` objects can be combined:
#' - if their environments contains objects of the same name but not identical
#' - if `object2` has unique code element placed before common element. This means that `object2`
#' in the environment of the `object2` was evaluated some extra code before which can influence
#' reproducibility
#' - more cases todo
#' @param object (`Quosure`)
#' @param object2 (`Quosure`)
#' @param overwrite (`logical(1)`) whether modified objects in the environment of the `object2`
#'  should overwrite their equivalents in the environment of the `object`.
#' @export
setMethod("join", signature("Quosure", "Quosure"), function(object, object2, overwrite = FALSE) {
  # todo: revise chunks_merge_chunks and make robust join method


  # object2 can't have modified object of the same name! See chunks_push_chunks
  common_names <- intersect(ls(object@env), ls(object2@env))
  is_identical_obj <- vapply(common_names, function(x) {
    identical(get(x, object@env), get(x, object2@env))
  }, logical(1))
  if (any(isFALSE(is_identical_obj)) && !overwrite) {
    stop(
      "join does not allow overwriting already calculated values.",
      " Following variables would have been overwritten:",
      paste("    -", names(is_identical_obj), collapse = "\n"),
      sep = "\n"
    )
  }

  # join expressions
  # > join should be an inteligent union
  unique_expr <- !(object2@code %in% object@code & names(object2@code) %in% names(object@code))
    # duplicated expr will probably have the same name also
    # unique_expr should have TRUE only at the end of the vector.
  object@code <- c(object@code, object2@code[unique_expr])

  # insert new objects to env
  new_names <- setdiff(ls(object2@env), ls(object@env))

  object@env <- .copy_env(object@env)
  lapply(new_names, function(x) assign(x, get(x, object2@env), object@env))

  object
})

#' Copy environment content to the other environment
#' To avoid sharing the same environment by multiplequo object (in reactives)
#' @keywords internal
.copy_env <- function(env) {
  # need to copy the objects from old env to new env
  # to avoid "chunks" sharing the same environment
  env_new <- new.env()
  for (i in ls(env)) {
    env_new[[i]] <- env[[i]]
  }
  env_new
}

#' Needed to determine if the `Quosure`'s code can be joined
#'
#' @keywords internal
.resolve_code_vector <- function(code, code2) {
  # only possible pattern for extra code: both are completelly different
  # then A <- B (but there should be no common variable names!)? what about rm method?

  # if  B has extra code which is not  at the end
  # only one object can have extra code at the

  # if B has extra code at the end and no object conflict
  # if A has extra code at the end and no object conflict
  #

  code_only_in_a <- which(!code %in% code2)
  code_only_in_b <- which(!code2 %in% code)

  if (!identical(
    code_only_in_a,
    utils::tail(seq_along(code), length(code_only_in_a))
  )) {
    # a can only have extra code at the end of the queue
    stop("only last index")
  }

  if (!identical(
    code_only_in_b,
    utils::tail(seq_along(code2), length(code_only_in_b))
  )) {
    # b can only have extra code at the end of the queue
    stop("only last index")
  }

}