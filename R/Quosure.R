#' Reproducible class with environment and code.
#'
#' @slot code (`character`) to reproduce the environment
#' @slot env (`environment`) environment which content was generated by the evaluation
#' of the `code` slot.
setClass(
  "Quosure",
  representation(env = "environment", code = "QCode"),
  prototype(env = new.env(parent = parent.env(.GlobalEnv)), code = new_qcode())
)

#' Initialize `Quosure` object
#'
#' Initialize `Quosure` object with `code` and `env`. In order to have `Quosure` reproducible
#' one needs to initialize with `env` which can be reproduced by the `code`. Alternatively, one
#' can create an empty `Quosure` and evaluate the expressions in this object.
#' @name new_quosure
#'
#' @param code (`character(1)` or `language`) code to evaluate. Accepts and stores comments also.
#' @param env (`environment`) Environment being a result of the `code` evaluation.
#'
#' @export
setGeneric("new_quosure", function(env = new.env(parent = parent.env(.GlobalEnv)), code = character(0)) {
  standardGeneric("new_quosure")
})

#' @rdname new_quosure
#' @export
setMethod(
  "new_quosure", signature(env = "environment", code = "character"),
  function(env, code) {
    lockEnvironment(env)

    if (is.null(names(code)) && length(code)) {
      names(code) <- make.unique(rep("initial code", length(code)))
    }

    qcode <- new_qcode(code)
    methods::new("Quosure", env = env, code = qcode)
  }
)

#' @rdname new_quosure
#' @export
setMethod(
  "new_quosure", signature(env = "environment", code = "expression"),
  function(env, code) {
    code_char <- as.character(code)
    new_quosure(env = env, code = code_char)
  }
)

#' @rdname new_quosure
#' @export
setMethod(
  "new_quosure", signature(env = "environment", code = "language"),
  function(env, code) {
    code_expr <- as.expression(code)
    new_quosure(env = env, code = code_expr)
  }
)

#' @rdname new_quosure
#' @export
setMethod(
  "new_quosure", signature(env = "environment", code = "ANY"),
  function(env, code) {
    quoted_expr <- substitute(code)
    new_quosure(env = env, code = quoted_expr)
  }
)

#' @rdname new_quosure
#' @export
setMethod(
  "new_quosure", signature(env = "list"),
  function(env, code) {
    if (!missing(code)) {
      warning(
        "`code` argument is ignored when creating Quosure from the list.",
        "\nPlease pass the code througn attr(<list>, 'code')"
      )
    }

    code <- attr(env, "code") # named
    if (length(code) == 0) {
      stop("To create the Quosure from the list it must contain 'code' attribute.")
    }

    if (checkmate::test_list(env, "reactive")) {
      env <- lapply(env, function(x) {
        if (inherits(x, "reactive")) {
          x()
        } else {
          x
        }
      })
    }
    new_quosure(env = list2env(env), code = code)
  }
)

#' @rdname new_quosure
#' @export
setMethod(
  "new_quosure", signature(code = "missing", env = "missing"),
  function(env, code) {
    new_quosure(env = env, code = code)
  }
)

#' Evaluate the code in the `Quosure` environment
#'
#' Given code is evaluated in the `Quosure` environment and appended to the `code` slot. This means
#' that state of the environment is always a result of the stored code (if `Quosure` was initialized)
#' with reproducible code.
#'
#' @name eval_code
#'
#' @param object (`Quosure`)
#' @param code (`character` or `language`) code to evaluate. Also accepts and stores comments
#' @param name (`character(1)`) name of the code block.
#'
#' @export
setGeneric("eval_code", function(object, code, name = "code") {
  standardGeneric("eval_code")
})

#' @rdname eval_code
#' @export
setMethod(
  "eval_code", signature("Quosure", "character"),
  function(object, code, name) {
    checkmate::assert_character(name, len = 1L)
    if (is.null(names(code))) {
      code <- paste(code, collapse = "\n")
      names(code) <- name
    }

    object@code <- join(object@code, new_qcode(code))

    # need to copy the objects from old env to new env
    # to avoid updating environments in the separate objects
    object@env <- .copy_env(object@env)
    eval(parse(text = code), envir = object@env)
    lockEnvironment(object@env)
    object
  }
)

#' @rdname eval_code
#' @export
setMethod(
  "eval_code", signature("Quosure", "expression"),
  function(object, code, name) {
    code_char <- as.character(code)
    eval_code(object, code_char, name = name)
  }
)

#' @rdname eval_code
#' @export
setMethod(
  "eval_code", signature("Quosure", "language"),
  function(object, code, name) {
    code_char <- as.expression(code)
    eval_code(object, code_char, name = name)
  }
)

#' @rdname eval_code
#' @export
setMethod(
  "eval_code", signature("Quosure", "ANY"),
  function(object, code, name) {
    code_expr <- substitute(code)
    eval_code(object, code_expr, name = name)
  }
)

#' Get object from the `Quosure` environment
#'
#' Get object from the `Quosure` environment.
#' @param object (`Quosure`)
#' @param var (`character(1)`) name of the variable to pull from the environment.
#' @name get_var
#' @export
setGeneric("get_var", function(object, var) {
  standardGeneric("get_var")
})


#' @rdname get_var
#' @export
setMethod("get_var", signature("Quosure", "character"), function(object, var) {
  get(var, envir = object@env)
})

#' @param x (`Quosure`)
#' @param i (`character`) name of the binding in environment (name of the variable)
#' @param j not used
#' @param ... not used
#' @rdname get_var
#' @export
setMethod("[[", c("Quosure", "ANY", "missing"), function(x, i, j, ...) {
  get_var(x, i)
})

#' Get code from `Quosure`
#'
#' @param object (`Quosure`)
#' @return named `character` with the reproducible code.
#' @export
setGeneric("get_code", function(object) {
  standardGeneric("get_code")
})

#' Get the code from the `Quosure`
#'
#' @param object (`Quosure`)
setMethod("get_code", signature("Quosure"), function(object) {
  object@code@code
})

setMethod("join", signature("Quosure", "Quosure"), function(x, y) {
  common_names <- intersect(ls(x@env), ls(y@env))
  is_overwritten <- vapply(common_names, function(xx) {
    !identical(get(xx, x@env), get(xx, y@env))
  }, logical(1))
  if (any(is_overwritten)) {
    stop(
      "Not possible to join Quosure objects if anything in their environment has been modified.\n",
      "Following object(s) have been modified:\n - ",
      paste(common_names[is_overwritten], collapse = "\n - ")
    )
  }

  # join expressions
  x@code <- join(x@code, y@code)

  # insert (and overwrite) objects from env2 to env
  x@env <- .copy_env(x@env)
  lapply(ls(y@env), function(xx) assign(xx, get(xx, y@env), x@env))

  x
})

#' Copy environment content to the other environment
#' To avoid sharing the same environment by multiplequo object (in reactives)
#' @keywords internal
.copy_env <- function(env) {
  # need to copy the objects from old env to new env
  # to avoid "chunks" sharing the same environment
  env_new <- new.env()
  for (i in ls(env)) {
    env_new[[i]] <- env[[i]]
  }
  env_new
}